from re import U
from turtle import pos, position
import sympy as sp
import matplotlib.pyplot as plt
import numpy as np

COULOMB_CONSTANT, MU_NAUGHT, EPSILON_NAUGHT, R = sp.symbols("k, \\mu_{0}, \\epsilon_{0}, r")

class Point_charge(object):
    position = list()
    charge = 0 
    k = 8.99 * 10**9

    def __init__(self, position: list[float], q: float) -> None:
        self.position = position
        self.charge = q
    

    def get_position(self) -> list[float]:
        """Get the position list of the point charge

        Returns:
            list[float]: position: either [x], [x,y], or [x,y,z]
        """
        return self.position


    def radious(self, point: list[float]) -> float:
        """Returns the radial distance from the given point

        Args:
            point (list[float]): point to get radial distance from

        Returns:
            float: radial distance from given point
        """
        if len(point) != len(self.position):
            raise RuntimeError(f"Point given does not match dimmension of point charge position. point dim:" \
                f"{len(point)} | charge dim: {len(self.position)}")
        
        sides_sum = 0
        for i in range(0,len(point)):
            sides_sum += abs(self.position[i] - point[i])**2
        
        return sides_sum**(1/2)
    

    def electric_field_magnitude(self, point: list[float]) -> float:
        """Return the electric field magnitude generated by this point charge at a given point

        Args:
            point (list[float]): x,y location of test point

        Returns:
            float: magnitude of electric field
        """
        return self.k * abs(self.charge) / self.radious(point)**2
    

    def theta(self, point: list[float]) -> float: 
        """Calculate the angle from point charge location to test point

        Args:
            point (list[float]): test point

        Returns:
            float: angle
        """
        return np.arccos(abs((point[0]-self.position[0]))/self.radious(point))


    def electric_field_x(self, point: list[float]) -> float:
        """Calculate the x component of the magnetic field generated by the point charge at a given point

        Args:
            point (list[float]): test point to check

        Returns:
            float: x component of electric field
        """
        magnitude = self.electric_field_magnitude(point) * np.cos(self.theta(point))
        magnitude = magnitude * -1 if point[0] < self.position[0] else magnitude
        return magnitude
            

    def electric_field_y(self, point: list[float]) -> float:
        """Calculate the y component of the magnetic field generated by the point charge at a given point

        Args:
            point (list[float]): test point to check

        Returns:
            float: y component of electric field
        """
        magnitude = self.electric_field_magnitude(point) * np.sin(self.theta(point))
        magnitude = magnitude * -1 if point[1] < self.position[1] else magnitude
        return magnitude


class Window(object):
    charges = list()

    def __init__(self, charges = []) -> None:
        self.charges = charges

    def add_point_charge(self, point_charge: Point_charge) -> None:
        """Add point charge to the test window

        Args:
            point_charge (Point_charge): Point charge object
        """
        self.charges.append(point_charge)

    def net_electric_field(self, test_point: list[float]) -> float:
        ex = 0
        ey = 0
        for pc in self.charges:
            ex += pc.electric_field_x(test_point)
            ey += pc.electric_field_y(test_point)
        
        return np.sqrt(pow(ex,2) + pow(ey,2))
    

    def electric_field_x(self, test_point: list[float]) -> float:
        ex = 0
        for pc in self.charges:
            ex += pc.electric_field_x(test_point)
        return ex


    def electric_field_y(self, test_point: list[float]) -> float:
        ey = 0
        for pc in self.charges:
            ey += pc.electric_field_y(test_point)
        return ey


# def coulombs_law_eqn(charge: float):
#     """
#     Determines the electric field at a point ``radius`` away from a single point
#     charge ``charge``.

#     E = k|q|/r^2

#     @param charge The charge of the point charge.
#     """

#     equation = "1/(4 * sp.pi * EPSILON_NAUGHT) * (abs(charge)) / R ** 2"

#     return eval(equation)


def main():
    # sp.init_printing()

    # res = coulombs_law_eqn(100)
    # print(res)

    # x = np.linspace(1, 10, 100)
    # y = [res.subs({R: r_val, EPSILON_NAUGHT: 1, sp.pi: np.pi}) for r_val in x]

    # plt.plot(x, y)
    # plt.show()

    # latex_str = "$" + sp.latex(res) + "$"    
    # sp.preview(latex_str, output="png", dvioptions=["-D","1200"])
    test_point = [1,3]
    a = Point_charge([10,7],10)
    b = Point_charge([-3,5], 8)

    window = Window()

    window.add_point_charge(a)
    window.add_point_charge(b)

    top_left = [-10,10]
    bottom_right = [10,-10]
    x_len = abs(top_left[0]) + abs(bottom_right[0])
    y_len = abs(top_left[1]) + abs(bottom_right[1])

    px = [ [0] * x_len for i in range(y_len+1)]
    py = [ [0] * x_len for i in range(y_len+1)]
    magx = [ [0] * x_len for i in range(y_len+1)]
    magy = [ [0] * x_len for i in range(y_len+1)]

    for i in range(top_left[0], bottom_right[0]+1):
        for j in range(bottom_right[1],top_left[1]+1):
            print(f"({i},{j})")
            px[i][j] = i
            py[i][j] = j
            try:
                magx[i][j] = window.electric_field_x([i,j])
                magy[i][j] = window.electric_field_y([i,j])

                magx[i][j] = 0 if abs(magx[i][j]) > 10000000000 else magx[i][j] 
                magy[i][j] = 0 if abs(magy[i][j]) > 10000000000 else magy[i][j] 
            except ZeroDivisionError:
                magx[i][j] = 0
                magy[i][j] = 0

    plt.quiver(px, py, magx, magy, color='b', units='xy', scale=10000000000)
    plt.title('Electric field')

    plt.grid()
    plt.show()
if __name__ == "__main__":
    main()
