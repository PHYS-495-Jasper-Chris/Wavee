"""
Calculate the electric field of solid circle of charge.
"""

import numpy as np

from PyQt6 import QtWidgets, QtCore

# pylint: disable=import-error
from equations.base_charge import BaseCharge
from equations.constants import COULOMB_CONSTANT, Point2D
from view.two_line_dialog import TwoLineDialog
# pylint: enable=import-error


class CircleCharge(BaseCharge):
    """
    A single circle of charge, with a position, radius, and a charge density.
    """

    def __init__(self, center: Point2D, radius: float, charge_density: float) -> None:
        self.center = center
        self.radius = radius
        self.charge_density = charge_density

    def electric_field_magnitude(self, point: Point2D) -> float:
        """
        The net magnitude of the electric field at the given point.

        Args:
            point (Point2D): The point to measure the field at.

        Returns:
            float: The net (signed) magnitude of the electric field at the given point, or zero if
            the magnitude is infinite.
        """

        # For simplicity, shift coordinates to have the center of the charge at the origin.
        relative_pos = self._relative_pos(point)

        radial_dist: float = np.sqrt(relative_pos.x**2 + relative_pos.y**2)
        cum_charge_rad = min(radial_dist, self.radius)

        charge_enc = np.pi * cum_charge_rad**2 * self.charge_density

        # E = k * q_enc / r^2
        return COULOMB_CONSTANT * charge_enc / radial_dist**2

    def electric_field_x(self, point: Point2D) -> float:
        """
        Calculate the x component of the magnetic field generated by the charge at a given point.

        Args:
            point (Point2D): test point to check.

        Returns:
            float: x component of electric field.
        """

        # The direction of the electric field is in the r direction. Get the angle of the shifted
        # coordinates, and take the cos of that.
        return self.electric_field_magnitude(point) * np.cos(self._theta(point))

    def electric_field_y(self, point: Point2D) -> float:
        """
        Calculate the y component of the magnetic field generated by the charge at a given point.

        Args:
            point (Point2D): test point to check.

        Returns:
            float: y component of electric field.
        """

        # The direction of the electric field is in the r direction. Get the angle of the shifted
        # coordinates, and take the sin of that.
        return self.electric_field_magnitude(point) * np.sin(self._theta(point))

    def open_menu(self, pos: QtCore.QPointF) -> bool:
        """
        Open a context menu for this charge.

        Configures options associated with the charge.

        Args:
            pos (QPointF): The location to open the menu at.

        Returns:
            bool: True if this charge should be deleted, False otherwise.
        """

        menu = QtWidgets.QMenu()
        set_charge = menu.addAction("Set Charge Density")
        set_radius = menu.addAction("Set Radius")
        set_center = menu.addAction("Set Center")
        rmv_charge = menu.addAction("Remove Charge")

        while True:
            action = menu.exec(pos.toPoint())

            if action == set_charge:
                val, success = QtWidgets.QInputDialog().getDouble(menu, "Set Charge Density",
                                                                  "Set Charge Density (C/m^2)")
                if success:
                    self.charge_density = val
            elif action == set_radius:
                val, success = QtWidgets.QInputDialog().getDouble(menu, "Set Radius",
                                                                  "Set Radius (m)")
                if success:
                    self.radius = val
            elif action == set_center:
                x_pos, y_pos, success = TwoLineDialog("X Position", "Y Position",
                                                      menu).get_doubles()

                if success and False not in np.isfinite([x_pos, y_pos]):
                    self.center = Point2D(x_pos, y_pos)
            elif action == rmv_charge:
                return True
            elif action is None:
                return False

    def _relative_pos(self, point: Point2D) -> Point2D:
        """
        Shifted coordinates with ``self.center`` at the origin.

        Args:
            point (Point2D): The point to get the offset from.

        Returns:
            The offset coordinates.
        """

        return Point2D(point.x - self.center.x, point.y - self.center.y)

    def _theta(self, point: Point2D) -> float:
        """
        Get the angle between ``point`` and ``self.center``.
        """

        x_dist, y_dist = self._relative_pos(point)

        return np.arctan2(y_dist, x_dist)
