"""
A cylindrical hollow ring of charge.
"""

import numpy as np

# pylint: disable=import-error
from equations.base_charge import BaseCharge
from equations.constants import COULOMB_CONSTANT, Point2D
# pylint: enable=import-error


class RingCharge(BaseCharge):
    """
    A cylindrical ring of charge.
    """

    def __init__(self, center: Point2D, inner_radius: float, outer_radius: float,
                 charge_density: float) -> None:
        """
        Initialize the ring of charge with a center, an inner radius, an outer radius, and a charge
        density.

        Args:
            center (Point2D): The center of the ring of charge.
            inner_radius (float): The inner radius of the ring of charge. Inside this, there is no
                charge.
            outer_radius (float): The outer radius of the ring of charge. Outside this, there is no
                charge.
            charge_density (float): The charge density, in C/m^2, between ``inner_radius`` and
                ``outer_radius``.
        """

        if inner_radius < 0 or outer_radius <= 0:
            raise RuntimeError(
                f"Inner radius {inner_radius} and outer radius {outer_radius} must be greater than "
                "0")

        if inner_radius >= outer_radius:
            raise RuntimeError(
                f"Inner radius {inner_radius} must be less than outer radius {outer_radius}")

        self.center = center
        self.inner_radius = inner_radius
        self.outer_radius = outer_radius
        self.charge_density = charge_density

    def electric_field_magnitude(self, point: Point2D) -> float:
        """
        Return the electric field magnitude generated by this ring of charge at a given point.

        Args:
            point (Point2D): x, y location of test point.

        Returns:
            float: magnitude of electric field.
        """

        # 3 conditions for Gauss's Law:
        # r <= inner_radius: q_enc = 0
        # inner_radius <= r <= outer_radius: q_enc = area of enclosed circle - area of inner circle
        # r >= outer_radius: q_enc = area of outer circle - area of inner circle

        x_pos, y_pos = self._relative_pos(point)
        radial_distance: float = np.sqrt(x_pos**2 + y_pos**2)

        q_enc = 0.0
        if radial_distance > self.inner_radius:
            effective_rad = min(radial_distance, self.outer_radius)
            # q_enc = Integral[ρ, {r, inner, rad}]
            # Since ρ is constant, this is Pi * (rad^2 - inner^2) * ρ
            q_enc = self.charge_density * np.pi * (effective_rad**2 - self.inner_radius**2)

        # E = k * q_enc / r^2
        return COULOMB_CONSTANT * q_enc / radial_distance**2

    def electric_field_x(self, point: Point2D) -> float:
        """
        Calculate the x component of the magnetic field generated by the charge at a given point.

        Args:
            point (Point2D): test point to check.

        Returns:
            float: x component of electric field.
        """

        return self.electric_field_magnitude(point) * np.cos(self._theta(point))

    def electric_field_y(self, point: Point2D) -> float:
        """
        Calculate the y component of the magnetic field generated by the charge at a given point.

        Args:
            point (Point2D): test point to check.

        Returns:
            float: y component of electric field.
        """

        return self.electric_field_magnitude(point) * np.sin(self._theta(point))

    def _relative_pos(self, point: Point2D) -> Point2D:
        """
        Shifted coordinates with ``self.center`` at the origin.

        Args:
            point (Point2D): The point to get the offset from.

        Returns:
            The offset coordinates.
        """

        return Point2D(point.x - self.center.x, point.y - self.center.y)

    def _theta(self, point: Point2D) -> float:
        """
        Get the angle between ``point`` and ``self.center``.
        """

        x_dist, y_dist = self._relative_pos(point)

        return np.arctan2(y_dist, x_dist)
