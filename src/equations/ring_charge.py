"""
A cylindrical hollow ring of charge.
"""

import numpy as np
import sympy
from PyQt6 import QtCore, QtWidgets
from sympy.abc import x, y

# pylint: disable=import-error
from equations.base_charge import BaseCharge
from equations.constants import COULOMB_CONSTANT, COULOMB_CONSTANT_SYM, Point2D
from view.multi_line_input_dialog import MultiLineInputDialog

# pylint: enable=import-error


class RingCharge(BaseCharge):
    """
    A cylindrical ring of charge.
    """

    def __init__(self, center: Point2D, inner_radius: float, outer_radius: float,
                 charge_density: float) -> None:
        """
        Initialize the ring of charge with a center, an inner radius, an outer radius, and a charge
        density.

        Args:
            center (Point2D): The center of the ring of charge.
            inner_radius (float): The inner radius of the ring of charge. Inside this, there is no
                charge.
            outer_radius (float): The outer radius of the ring of charge. Outside this, there is no
                charge.
            charge_density (float): The charge density, in C/m^2, between ``inner_radius`` and
                ``outer_radius``.
        """

        if inner_radius < 0 or outer_radius <= 0:
            raise RuntimeError(
                f"Inner radius {inner_radius} and outer radius {outer_radius} must be greater than "
                "0")

        if inner_radius >= outer_radius:
            raise RuntimeError(
                f"Inner radius {inner_radius} must be less than outer radius {outer_radius}")

        self.center = center
        self.inner_radius = inner_radius
        self.outer_radius = outer_radius
        self.charge_density = charge_density

    def electric_field_magnitude(self, point: Point2D) -> float:
        """
        Return the electric field magnitude generated by this ring of charge at a given point.

        Args:
            point (Point2D): x, y location of test point.

        Returns:
            float: magnitude of electric field.
        """

        # 3 conditions for Gauss's Law:
        # r <= inner_radius: q_enc = 0
        # inner_radius <= r <= outer_radius: q_enc = area of enclosed circle - area of inner circle
        # r >= outer_radius: q_enc = area of outer circle - area of inner circle

        x_pos, y_pos = self._relative_pos(point)
        radial_distance: float = np.sqrt(x_pos**2 + y_pos**2)

        # Make sure we don't divide by 0
        if radial_distance == 0.0:
            return 0.0

        q_enc = 0.0
        if radial_distance > self.inner_radius:
            effective_rad = min(radial_distance, self.outer_radius)
            # q_enc = Integral[ρ, {r, inner, rad}]
            # Since ρ is constant, this is Pi * (rad^2 - inner^2) * ρ
            q_enc = self.charge_density * np.pi * (effective_rad**2 - self.inner_radius**2)

        # E = k * q_enc / 2 * pi * r
        return COULOMB_CONSTANT * q_enc / (2 * np.pi * radial_distance)  # type: ignore

    def electric_field_x(self, point: Point2D) -> float:
        """
        Calculate the x component of the magnetic field generated by the charge at a given point.

        Args:
            point (Point2D): test point to check.

        Returns:
            float: x component of electric field.
        """

        return self.electric_field_magnitude(point) * np.cos(self._theta(point))

    def electric_field_y(self, point: Point2D) -> float:
        """
        Calculate the y component of the magnetic field generated by the charge at a given point.

        Args:
            point (Point2D): test point to check.

        Returns:
            float: y component of electric field.
        """

        return self.electric_field_magnitude(point) * np.sin(self._theta(point))

    def open_menu(self, pos: QtCore.QPointF) -> bool:
        """
        Open a context menu for this charge.

        Configures options associated with the charge.

        Args:
            pos (QPointF): The location to open the menu at.

        Returns:
            bool: True if this charge should be deleted, False otherwise.
        """

        menu = QtWidgets.QMenu()
        set_charge = menu.addAction("Set Charge Density")
        set_radii = menu.addAction("Set Radii")
        set_center = menu.addAction("Set Center")
        rmv_charge = menu.addAction("Remove Charge")

        while True:
            action = menu.exec(pos.toPoint())

            if action == set_charge:
                val, success = QtWidgets.QInputDialog().getDouble(menu, "Set Charge Density",
                                                                  "Set Charge Density (C/m^2)")
                if success:
                    self.charge_density = val
                    self.charge_updated()
            elif action == set_radii:
                (inner_radius,
                 outer_radius), success = MultiLineInputDialog(["Inner Radius", "Outer Radius"],
                                                               menu).get_doubles(minimum=0.0)

                if success and False not in np.isfinite([inner_radius, outer_radius
                                                        ]) and 0 <= inner_radius < outer_radius:
                    self.inner_radius, self.outer_radius = inner_radius, outer_radius
                    self.charge_updated()
            elif action == set_center:
                new_center, success = MultiLineInputDialog(["X Position", "Y Position"],
                                                           menu).get_doubles()

                if success and False not in np.isfinite(new_center):
                    self.center = Point2D(*new_center)
                    self.charge_updated()
            elif action == rmv_charge:
                return True
            elif action is None:
                return False

    def electric_field_mag_eqn(self) -> sympy.Basic:
        """
        Returns the position-independent electric field equation of magnitude for this ring charge.

        Returns:
            Basic: sympy representation of the signed magnitude of the electric field.
        """

        # r = sqrt((x - x0)**2 + (y - y0)**2)
        r_sym = sympy.sqrt((self.center.x - x)**2 + (self.center.y - y)**2)

        # q_enc = Integral[ρ, {r, inner, rad}]
        if isinstance(self.charge_density, (float, int)):
            q_enc = self.charge_density * sympy.pi * (r_sym**2 - self.inner_radius**2)
            q_tot = self.charge_density * sympy.pi * (self.outer_radius**2 - self.inner_radius**2)
        else:
            rp_sym = sympy.Symbol("r'")
            q_enc = sympy.Integral(self.charge_density, (rp_sym, self.inner_radius, r_sym))
            q_tot = sympy.Integral(self.charge_density,
                                   (rp_sym, self.inner_radius, self.outer_radius))

        # E = E = k * q_enc / 2 * pi * r
        eqn = COULOMB_CONSTANT_SYM * q_enc / (2 * sympy.pi * r_sym)
        eqn_outer = COULOMB_CONSTANT_SYM * q_tot / (2 * sympy.pi * r_sym)

        inner_cond = False if self.inner_radius == 0 else r_sym <= self.inner_radius

        middle_cond = r_sym <= self.outer_radius if self.inner_radius == 0 else sympy.And(
            r_sym >= self.inner_radius, r_sym <= self.outer_radius)

        return sympy.Piecewise((eqn_outer, r_sym >= self.outer_radius), (eqn, middle_cond),
                               (0, inner_cond))

    def electric_field_x_eqn(self) -> sympy.Basic:
        """
        Returns the position-independent electric field x-component equation for this ring charge.

        Returns:
            Basic: sympy representation of the x-component of the electric field.
        """

        mag = self.electric_field_mag_eqn()
        x_comp = sympy.cos(self._theta_eqn())
        return mag * x_comp  # type: ignore

    def electric_field_y_eqn(self) -> sympy.Basic:
        """
        Returns the position-independent electric field y-component equation for this ring charge.

        Returns:
            Basic: sympy representation of the y-component of the electric field.
        """

        mag = self.electric_field_mag_eqn()
        y_comp = sympy.sin(self._theta_eqn())
        return mag * y_comp  # type: ignore

    def _relative_pos(self, point: Point2D) -> Point2D:
        """
        Shifted coordinates with ``self.center`` at the origin.

        Args:
            point (Point2D): The point to get the offset from.

        Returns:
            The offset coordinates.
        """

        return Point2D(point.x - self.center.x, point.y - self.center.y)

    def _theta(self, point: Point2D) -> float:
        """
        Get the angle between ``point`` and ``self.center``.
        """

        x_dist, y_dist = self._relative_pos(point)

        return np.arctan2(y_dist, x_dist)

    def _theta_eqn(self) -> sympy.Basic:
        """
        Returns the angle between any x, y point and the center.
        """

        x_dist, y_dist = x - self.center.x, y - self.center.y
        angle = sympy.atan2(y_dist, x_dist)

        return angle  # type: ignore
